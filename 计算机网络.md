# 计算机网络

## TCP/IP模型（四层模型）

应用层  | 传输层(TCP) 网络层(IP) | 网络接口层

- **应用(程序)层**，为用户提供网络服务。它直接与用户应用程序交互，处理应用程序之间的通信细节。支持 HTTP、HTTPS、SMTP 、DNS、CDN等最终用户进程。数据单元通常称为消息或数据。

- **传输层**，提供端到端（主机到主机或进程到进程）的可靠或不可靠的数据传输服务。处理主机到主机的通信（TCP：面向连接的协议，三次握手四次挥手，具有可靠传输、UDP：无连接的协议，不可靠的传输）

- **网络层**，负责在源主机和目标主机之间选择最佳路径来传输数据包（也称为分组），实现网络互连和路由选择。作用是逻辑寻址（IP地址）、路由选择、数据包分片、网络互连。经典协议：IP：IPV4/IPV6 可靠性由TCP保证。
- **网络接口层**，负责在物理网络中（如一个局域网内）传输数据帧 (Frame)。它处理与物理介质（如电缆、光纤、无线信号）相关的细节，以及如何在相邻节点之间可靠地传输数据。作用如物理寻址（MAC地址：唯一的物理地址用于设备标识）。经典协议：以太网，Wi-Fi。

## 数据在TCP/IP模型中的封装与解封装

发送方：

应用层（产生数据/消息）

 传输层（数据分段，添加TCP/UDP头部：端口号等，形成TCP/UDP数据段）

 网络层（为传输层的数据段加上IP头部：IP地址等，形成IP数据包）

 网络接口层（为IP数据包添加帧头部和尾部：MAC地址等，形成数据帧，转换为比特流在物理介质上传输）

接收方：

网络接口层（从物理介质接受比特流，组装成数据帧，检查MAC地址和校验和，去掉帧头帧尾，将IP数据包向上传给网络层）

网络层（检查IP头部，根据IP地址判断是否是自己的数据包，去掉IP头部，将数据段上传给传输层）

传输层（根据TCP/UDP头部的端口号 将数据交给相应的应用程序进程，进行数据重组：TCP或直接交付:UDP，去掉TCP/UDP头部）

应用层（接收数据）

## 应用层

### HTTP报文有哪些部分

![image-20250506183304758](C:\Users\11965\Documents\八股\计算机网络.assets\image-20250506183304758.png)

```json
HTTP请求报文结构：
<方法> <请求目标> <HTTP版本>  (请求行)
<头部名称1>: <头部值1>
<头部名称2>: <头部值2>
...
<头部名称N>: <头部值N>
                                    (空行 - CRLF)
<可选的请求主体>
```

```json
HTTP响应报文结构:
<HTTP版本> <状态码> <原因短语>  (状态行)
<头部名称1>: <头部值1>
<头部名称2>: <头部值2>
...
<头部名称N>: <头部值N>
                                    (空行 - CRLF)
<可选的响应主体>
```

**请求报文：**

- 请求行：包含请求方法、请求目标（URL或URI）和HTTP协议版本。
- 请求头部：包含关于请求的附加信息，如Host、User-Agent、Content-Type等。
- 空行：请求头部和请求体之间用空行分隔。
- 请求体：可选，包含请求的数据，通常用于POST请求等需要传输数据的情况。

**响应报文：**

- 状态行：包含HTTP协议版本、状态码和状态信息。
- 响应头部：包含关于响应的附加信息，如Content-Type、Content-Length等。
- 空行：响应头部和响应体之间用空行分隔。

- 响应体：包含响应的数据，通常是服务器返回的HTML、JSON等内容。

### HTTP常用状态码

1xx:提示信息

2xx:成功

3xx:重定向 

301：永久重定向（说明请求的资源已经不存在了，需改用新的 URL 再次访问。）；302：临时重定向（说明请求的资源还在，但暂时需要用另一个 URL 来访问。）；

4xx:客户端错误 

404：无法找到此页面；405：请求的方法类型不支持；

5xx:服务器错误 

500：服务器内部出错。 502 Bad Gateway：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。 504 Gateway Time-out：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器收到响应。

### HTTP常用请求类型

- GET：用于请求获取指定资源，通常用于获取数据。（**GET 方法就是安全且幂等的**，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以可以进行缓存操作。）
- HEAD：类似于GET请求，但只返回资源的头部信息，用于获取资源的元数据而不获取实际内容。

- POST：用于向服务器提交数据，通常用于提交表单数据或进行资源的创建（因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是**不安全**的，且多次提交数据就会创建多个资源，所以**不是幂等**的。）。

- PUT：用于向服务器更新指定资源，通常用于更新已存在的资源。

- DELETE：用于请求服务器删除指定资源。

### HTTP长连接

HTTP 协议采用的是「请求-应答」的模式，也就是客户端发起了请求，服务端才会返回响应。

由于 HTTP 是基于 TCP 传输协议实现的，客户端与服务端要进行 HTTP 通信前，需要先建立 TCP 连接，然后客户端发送 HTTP 请求，服务端收到后就返回响应，至此「请求-应答」的模式就完成了，随后就会释放 TCP 连接。

如果每次请求都要经历这样的过程：建立 TCP（三次挥手） -> 请求资源 -> 响应资源 -> 释放连接（四次挥手），那么此方式就是 **HTTP 短连接**。

HTTP 的 Keep-Alive 可以使用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，避免了连接建立和释放的开销，这个方法称为 **HTTP 长连接**。

HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。

### HTTP与HTTPS默认端口

http 是 80，https 默认是 443。

### HTTP1.1对请求做拆包

在HTTP/1.1中，请求的拆包是通过"Content-Length"头字段来进行的。该字段指示了请求正文的长度，服务器可以根据该长度来正确接收和解析请求。

### HTTP断点重传是什么？

断点续传是HTTP/1.1协议支持的特性。实现断点续传的功能，需要客户端记录下当前的下载进度，并在需要续传的时候通知服务端本次需要下载的内容片段。

断点续传中4个HTTP头不可少的，**分别是Range头、Content-Range头、Accept-Ranges头、Content-Length头**。其中第一个Range头是客户端发过来的，后面3个头需要服务端发送给客户端。下面是它们的说明：

- **Accept-Ranges（bytes）：**这个值声明了可被接受的每一个范围请求, 大多数情况下是字节数 bytes
- **Range（ bytes=start-end）：**Range是浏览器告知服务器所需分部分内容范围的消息头。
- **Content-Length（bytes）**：响应报文主体部分的大小。
- **Content-Range (bytes = (start-end)/total)**：由服务器发送，且仅在相应部分内容（状态码206）时使用，它告诉客户端当前发送的数据片段在**整个资源**中的位置以及整个资源的总大小。

### HTTP为什么不安全？

HTTP 由于是明文传输，所以安全上存在以下三个风险：

- **窃听风险**，比如通信链路上可以获取通信内容，用户号容易没。
- **篡改风险**，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。
- **冒充风险**，比如冒充淘宝网站，用户钱容易没。

**HTTPS** 在 HTTP 与 TCP 层之间加入了 SSL/TLS 协议，可以很好的解决了上述的风险：

- **信息加密**：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。
- **校验机制**：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。
- **身份证书**：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。

![image-20250506185742179](C:\Users\11965\Documents\八股\计算机网络.assets\image-20250506185742179.png)

### HTTP和HTTPS 的区别

- HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
- HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
- 两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。
- HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

### HTTPS握手过程

传统的 TLS 握手基本都是使用 RSA 算法来实现密钥交换的，在将 TLS 证书部署服务端时，证书文件其实就是服务端的公钥，会在 TLS 握手阶段传递给客户端，而服务端的私钥则一直留在服务端，一定要确保私钥不能被窃取。

在 RSA 密钥协商算法中，客户端会生成随机密钥，并使用服务端的公钥加密后再传给服务端。根据非对称加密算法，公钥加密的消息仅能通过私钥解密，这样服务端解密后，双方就得到了相同的密钥，再用它加密应用消息。

 TLS 握手过程：一共经历了四次握手。

> TLS 第一次握手（客户端提供随机数字A TLS版本 加密方法  握手结束）

首先，由客户端向服务器发起加密通信请求。在这一步，客户端主要向服务器发送以下信息：

- 客户端支持的 TLS 协议版本，如 TLS 1.2 版本。
- 客户端生产的随机数（Client Random），后面用于生成「会话秘钥」条件之一。
- 客户端支持的密码套件列表，如 RSA 加密算法。

> TLS 第二次握手（服务器 确定TLS版本 选定加密方法 提供数字证书（服务器公钥） 提供数字B 握手结束）

服务器收到客户端请求后，向客户端发出响应。服务器回应的内容有如下内容：

- 确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。
- 服务器生产的随机数（Server Random），也是后面用于生产「会话秘钥」条件之一。
- 确认的密码套件列表，如 RSA 加密算法。
- 服务器的数字证书。

> TLS 第三次握手（客户端验证服务器数字证书 提供随机数字C 并用服务器的公钥加密 客户端使用ABC计算会话密钥 并提醒更改加密规格 握手结束（加密））

客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。

如果证书没有问题，客户端会**从数字证书中取出服务器的公钥**，然后使用它加密报文，向服务器发送如下信息：

- 一个随机数（pre-master key）。该随机数会被服务器公钥加密。
- 加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。
- 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。

上面第一项的随机数是整个握手阶段的第三个随机数，会发给服务端，所以这个随机数客户端和服务端都是一样的。

**服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」**。

> TLS 第四次握手（用公钥解密数字C 服务器使用ABC计算会话密钥 提醒客户端更改加密规格 握手结束（加密））

服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。

然后，向客户端发送最后的信息：

- 加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。
- 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。

至此，整个 TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。

### HTTPS是如何防范中间人的攻击？

主要通过加密和身份校验机制来防范中间人攻击的:

- 加密：https 握手期间会通过非对称加密的方式来协商出对称加密密钥。
- 身份校验：服务器会向证书颁发机构申请数字证书，证书中包含了服务器的公钥和其他相关信息。当客户端与服务器建立连接时，服务器会将证书发送给客户端。客户端会验证证书的合法性，包括检查证书的有效期、颁发机构的信任等。如果验证通过，客户端会使用证书中的公钥来加密通信数据，并将加密后的数据发送给服务器，然后由服务端用私钥解密。

中间人攻击的关键在于攻击者冒充服务器与客户端建立连接，并同时与服务器建立连接。

但由于**攻击者无法获得服务器的私钥**，因此无法正确解密客户端发送的加密数据。同时，客户端会在**建立连接时验证服务器的证书**，如果证书验证失败或存在问题，客户端会发出警告或中止连接。

### HTTP 1.1和2.0的区别是什么？

HTTP/2 相比 HTTP/1.1 性能上的改进：

- **头部压缩**：HTTP/2 会**压缩头**（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你**消除重复的部分**。这就是所谓的 HPACK 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就**提高速度**了。
- **二进制格式**：HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了**二进制格式**，头信息和数据体都是二进制，并且统称为帧（frame）：**头信息帧（Headers Frame）和数据帧（Data Frame）**。这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这**增加了数据传输的效率**。
- **并发传输**：引出了 Stream 概念，多个 Stream 复用在一条 TCP 连接。解决了HTTP/1.1 队头阻塞的问题：
- **服务器主动推送资源**：HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务端不再是被动地响应，可以**主动**向客户端发送消息。

### HTTP进行TCP连接之后，在什么情况下会中断

- 当服务端或者客户端执行 close 系统调用的时候，会发送FIN报文，就会进行四次挥手的过程
- 当发送方发送了数据之后，接收方超过一段时间没有响应ACK报文，发送方重传数据达到最大次数的时候，就会断开TCP连接
- 当HTTP长时间没有进行请求和响应的时候，超过一定的时间，就会释放连接

### HTTP、SOCKET和TCP的区别

HTTP是应用层协议，定义了客户端和服务器之间交换的数据格式和规则；Socket是通信的一端，提供了网络通信的接口；TCP是传输层协议，负责在网络中建立可靠的数据传输连接。它们在网络通信中扮演不同的角色和层次。

- HTTP是一种用于传输超文本数据的应用层协议，用于在客户端和服务器之间传输和显示Web页面。
- **Socket（套接字）是一个应用程序编程接口（API），它位于应用程序层和传输层之间，允许应用程序层的进程使用传输层提供的服务（主要是TCP或UDP协议）来进行网络通信。**其在概念上和功能上紧密地**连接了应用程序层和传输层**，是实现网络通信编程的关键组件。
- TCP是一种面向连接的、可靠的传输层协议，负责在通信的两端之间建立可靠的数据传输连接。