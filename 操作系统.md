# 操作系统

## 用户态和内核态

### 用户态和内核态的区别？

内核态和用户态是操作系统中的两种运行模式。它们的主要区别在于权限和可执行的操作：

- 内核态（Kernel Mode）：在内核态下，CPU可以执行所有的指令和访问所有的硬件资源。这种模式下的操作具有更高的权限，主要用于操作系统内核的运行。
- 用户态（User Mode）：在用户态下，CPU只能执行部分指令集，无法直接访问硬件资源。这种模式下的操作权限较低，主要用于运行用户程序。

内核态的底层操作主要包括：内存管理、进程管理、设备驱动程序控制、系统调用等。这些操作涉及到操作系统的核心功能，需要较高的权限来执行。

分为内核态和用户态的原因主要有以下几点：

- 安全性：通过对权限的划分，用户程序无法直接访问硬件资源，从而避免了恶意程序对系统资源的破坏。
- 稳定性：用户态程序出现问题时，不会影响到整个系统，避免了程序故障导致系统崩溃的风险。
- 隔离性：内核态和用户态的划分使得操作系统内核与用户程序之间有了明确的边界，有利于系统的模块化和维护。

内核态和用户态的划分有助于保证操作系统的安全性、稳定性和易维护性。

## 进程管理

### 线程和进程的区别是什么？

![image-20250506193635330](C:\Users\11965\Documents\八股\操作系统.assets\image-20250506193635330.png)

- **本质区别**：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位
- **在开销方面**：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小
- **稳定性方面**：进程中某个线程如果崩溃了，可能会导致整个进程都崩溃。而进程中的子进程崩溃，并不会影响其他进程。
- **内存分配方面**：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源
- **包含关系**：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线。

### 进程，线程，协程的区别是什么？

- **进程**。进程是**操作系统中进行资源分配和调度的基本单位**，它拥有自己的独立内存空间和系统资源。**每个进程都有独立的堆和栈，不与其他进程共享**。进程间通信需要通过特定的机制，如管道、消息队列、信号量等。由于进程拥有独立的内存空间，因此其**稳定性和安全性相对较高**，但同时**上下文切换的开销也较大**，因为需要保存和恢复整个进程的状态。
- **线程**。线程是进程内的一个执行单元，也是**CPU调度和分派的基本单位**。与进程不同，**线程共享进程的内存空间，包括堆和全局变量**。线程之间通信更加高效，因为它们可以**直接读写共享内存**。线程的**上下文切换开销较小**，因为只需要保存和恢复线程的上下文，而不是整个进程的状态。然而，由于多个线程共享内存空间，因此**存在数据竞争和线程安全的问题，需要通过同步和互斥机制来解决。**
- **协程**。协程是一种**用户态的轻量级线程，其调度完全由用户程序控制，而不需要内核的参与。其存在于线程之中**。协程拥有自己的**寄存器上下文和栈，但与其他协程共享堆内存。**协程的**切换开销非常小**，因为只需要保存和恢复协程的上下文，而无需进行内核级的上下文切换。这使得协程在处理大量并发任务时具有非常高的效率。然而，**协程需要程序员显式地进行调度和管理，相对于线程和进程来说，其编程模型更为复杂。**
- J**ava与协程的关系**：虚拟线程 （Java21）

### 进程是分配资源的基本单位，那么这个资源指的是什么？

虚拟内存、文件句柄（操作系统分配给已打开文件的标识符，用于管理文件操作。）、信号量（是一种用于进程或线程同步的机制，主要用于控制对共享资源的访问或协调多个进程/线程的执行。它是一个计数器，记录可用资源的数量，通过原子操作（如P操作和V操作）来管理并发访问。）等资源。

###  讲下为什么进程之下还要设计线程？

- 实体之间可以并发运行；
- 实体之间共享相同的地址空间；

线程之间可以并发运行且共享相同的地址空间。

### 多线程比单线程的优势，劣势？

- 多线程比单线程的**优势**：提高程序的运行效率，可以充分利用多核处理器的资源，同时处理多个任务，加快程序的执行速度。
- 多线程比单线程的**劣势**：存在多线程数据竞争访问的问题，需要通过锁机制来保证线程安全，增加了加锁的开销，并且还会有死锁的风险。多线程会消耗更多系统资源，如CPU和内存，因为每个线程都需要占用一定的内存和处理时间。

### 多线程是不是越多越好，太多会有什么问题？

多线程不一定越多越好，过多的线程可能会导致一些问题。

- 切换开销：线程的创建和切换会消耗系统资源，包括内存和CPU。如果创建太多线程，会占用大量的系统资源，导致系统负载过高，某个线程崩溃后，可能会导致进程崩溃。
- 死锁的问题：过多的线程可能会导致竞争条件和死锁。竞争条件指的是多个线程同时访问和修改共享资源，如果没有合适的同步机制，可能会导致数据不一致或错误的结果。而死锁则是指多个线程相互等待对方释放资源，导致程序无法继续执行。

### 进程切换和线程切换的区别？

- 进程切换：进程切换涉及到更多的内容，包括整个进程的地址空间、全局变量、文件描述符等。因此，进程切换的开销通常比线程切换大。

- 线程切换：线程切换只涉及到线程的堆栈、寄存器和程序计数器等，不涉及进程级别的资源，因此线程切换的开销较小。

### 线程切换为什么比进程切换快，节省了什么资源？

线程切换比进程切换快是因为线程共享同一进程的地址空间和资源，线程切换时只需切换堆栈和程序计数器等少量信息，而不需要切换地址空间，避免了进程切换时需要切换内存映射表等大量资源的开销，从而节省了时间和系统资源。

### 线程切换详细过程是怎么样的？上下文保存在哪里？

线程切换的详细过程可以分为以下几个步骤：

- 上下文保存：当操作系统决定切换到另一个线程时，它首先会保存当前线程的上下文信息。上下文信息包括寄存器状态、程序计数器、堆栈指针等，用于保存线程的执行状态。
- 切换到调度器：操作系统将执行权切换到调度器（Scheduler）。调度器负责选择下一个要执行的线程，并根据调度算法做出决策。
- 上下文恢复：调度器选择了下一个要执行的线程后，它会从该线程保存的上下文信息中恢复线程的执行状态。
- 切换到新线程：调度器将执行权切换到新线程，使其开始执行。

上下文信息的保存通常由操作系统负责管理，具体保存在哪里取决于操作系统的实现方式。一般情况下，上下文信息会保存在线程的控制块（Thread Control Block，TCB）中。

TCB是操作系统用于管理线程的数据结构，包含了线程的状态、寄存器的值、堆栈信息等。当发生线程切换时，操作系统会通过切换TCB来保存和恢复线程的上下文信息。

**总结来说：**

1. **中断/系统调用** 触发切换。

2. CPU进入 **内核模式**。

3. 操作系统**保存**当前正在运行的线程 A 的上下文（我们称之为 **上下文A<sub>current</sub>**）到 **线程 A 的 TCB (TCB<sub>A</sub>)** 中。

4. 内核执行 **调度器**，根据调度策略选择下一个要运行的线程（比如线程 B）。

5. 操作系统从 **线程 B 的 TCB (TCB<sub>B</sub>)** 中加载并**恢复**线程 B 上一次被切换出去时保存的上下文（我们称之为 **上下文B<sub>previous</sub>**）到 CPU 的寄存器中。

6. CPU切换回 **用户模式**，线程 B 从其 **上下文B<sub>previous</sub>** 所指示的状态开始（或继续）执行。

注意：如果有y个CPU核心与x条线程 相当于有x个虚拟工人（原本y个 但由于技术进步相当于x个）在无数条流水线上打螺丝 对于每个工人 都会有当前流水线的记录（螺丝拧到哪一步了） 在切换到一条新流水线时候 他会查看记录 接着拧螺丝 拧几下触发切换时会更新记录 接着走向切换的流水线 重复操作。